# RLP编码
`RLP`（Recursive Length Prefix）即递归长度前缀编码， 不定义任何指定的数据类型， 仅以嵌套数组的形式存储结构。
`RLP`简化了编码的类型，只定义了两种类型编码：
- 字符串（byte数组）
- 字符串（byte数组）的数组，也就是`列表`.

## 5条编码规则
### 规则一:
对于值在[0, 127]（十六进制[0x00, 0x7f]）之间的单个字节，其编码是其本身；无需前缀。

```text
a的编码是97
```
### 规则二:
如果字符串的长度为`0-55`个字节之间，编码的结果是数组本身，再加上`0x80（128） + 字符串二进制长度`作为前缀， 前缀范围是：[0x80, 0xb7] 即十进制[128, 183]。

```text
空字符串的编码是128，即 128=128+0
abc的编码是131 97 98 99，其实131=128+len("abc"), 97 98 99依次是`a b c`
```
### 规则三:
如果字符串（数组）长度`大于55`字节，编码结果第一个值是`0xb7（183）+ 数组长度的编码的字节长度`，
然后是数组长度本身的编码，最后是byte数组的编码（共三个部分）。前缀范围是：[0xb8, 0xbf] 即十进制[184, 191]。

```text
编码一个重复1024次"a"的字符串，其结果是`185 4 0 97 97 97 ...
```
1024（2的10次方）按照大端编码是`0000 0000 001`转换为十六进制是`0 0 4 0`，省略前面的0,长度为`2`， 因此`185 = 183 + 2`

```text
大端编码(BigEndian): 低字节在高内存地址 ; 小端编码(LittleEndian): 低字节在低内存地址
```
### 规则四:
如果`列表`总内容RLP编码后字节长度`小于55`，编码结果第一位是`0xc0（192） + 列表内容编码的长度`，
然后依次连接各个子列表的编码，前缀范围是：`[0xc0, 0xf7]` 即十进制`[192,247]`。

```text
空列表[]编码结果为：192
["abc", "def"]的编码结果是 200 131 97 98 99 131 100 101 102
```
其中abc的编码是`131 97 98 99`, `131 = 128 + len("abc")` ， 
abc的编码长度是`4`，同样`def`的编码是`131 100 101 102`，编码长度是4，两个子字符串的编码后总长度为`8`，编码结果的第一位 `200 = 192 + 8`

### 规则五:
如果`列表`总内容RLP编码后字节长度`超过55`，编码结果第一位是`0xf7（247） + 列表长度的编码长度`，
然后是列表长度本身的编码，最后依次连接子列表的编码，前缀范围是：`[0xf8, 0xff]` 即十进制`[247,255]`。

```text
["The length of this sentence is more than 55 bytes, ", "I know it because I pre-designed it"]
```
其中前两个字节的计算方式如下：

1. "The length of this sentence is more than 55 bytes, "的长度为`51(0x33)`，根据`规则二`得出前缀`179 （0xb3 = 0x80 + 0x33 ）`
2. "I know it because I pre-designed it"的长度为`35(0x23)`，根据`规则二`得出前缀`163 （0xa3 = 0x80 + 0x23)`
3. 列表长度本身的编码为：`51 + 35 + 2(个子串的前缀占用) = 88 （0x58）`
4. 最后根据`规则五`，0x58只占用一个字节，即 `247(0xf7) + 1 = 248` ， 前缀为 `248`。

的编码结果表示是:

```text
// 前缀
248 // 根据规则五，长度超过55，247+1=248
// 列表总长度
88 // 51+1+35+1=88
// 字符串一
179 // 长度未超过55，那么使用规则二，0x80 + 0x33=0xb3；（128+51=179）
    // 字符串总长度为51(0x33)
84 104 101 32 108 101 110 103 116 104 32 111 102 32 116 104 105 115 32 115 101 110 116 101 110 99 101 32 105 115 32 109 111 114 101 32 116 104 97 110 32 53 53 32 98 121 116 101 115 44 32 
// 字符串二
163 // 长度未超过55，那么使用规则二，0x80 + 0x23=0xa3；（128+35=163）
    // 字符串总长度为35(0x23)
73 32 107 110 111 119 32 105 116 32 98 101 99 97 117 115 101 32 73 32 112 114 101 45 100 101 115 105 103 110 101 100 32 105 11
```

## 注意点
- rlp 不支持小写字符开头的成员变量
- 不支持int类型的成员变量